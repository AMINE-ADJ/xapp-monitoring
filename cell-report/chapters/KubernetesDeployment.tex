\chapter{Kubernetes-Based Deployment}
\label{chap:deployment}

This chapter details the containerized deployment of the 5G experimentation platform using Kubernetes. The orchestration layer provides automated deployment, scaling, service discovery, and network management for all platform components.

\section{Kubernetes Environment}

The platform is deployed on Minikube, a local Kubernetes implementation suitable for development and experimentation. The cluster configuration provides sufficient resources for running the complete 5G network stack.

\subsection{Cluster Configuration}

\begin{table}[H]
\centering
\caption{Kubernetes cluster configuration}
\label{tab:k8s_config}
\begin{tabular}{|l|l|}
\hline
\textbf{Parameter} & \textbf{Value} \\
\hline
Kubernetes Distribution & Minikube \\
\hline
Container Runtime & Docker \\
\hline
CNI Plugin & Kindnet / Bridge \\
\hline
Namespace & blueprint \\
\hline
CPU Allocation & 8 cores \\
\hline
Memory Allocation & 16 GB \\
\hline
\end{tabular}
\end{table}

\subsection{Namespace Organization}

All 5G network components are deployed within a dedicated Kubernetes namespace (\texttt{blueprint}), providing logical isolation and simplified resource management. This namespace contains:

\begin{itemize}
    \item Core Network Function pods (AMF, SMF, UPF, UDM, UDR, NRF, AUSF)
    \item MySQL database for subscriber data
    \item gNodeB pod with E2 Agent
    \item NR-UE pod for simulated user equipment
    \item FlexRIC pod hosting the near-RT RIC
\end{itemize}

\section{Pod Deployment Architecture}

Each network component is deployed as an individual Kubernetes pod, enabling independent lifecycle management and resource allocation.

\subsection{Core Network Pods}

\begin{table}[H]
\centering
\caption{5G Core Network pod deployments}
\label{tab:core_pods}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Pod Name} & \textbf{Image} & \textbf{Exposed Ports} \\
\hline
oai-nrf & oaisoftwarealliance/oai-nrf:v1.5.1 & 8080 (SBI) \\
\hline
oai-amf & oaisoftwarealliance/oai-amf:v1.5.1 & 8080 (SBI), 38412 (NGAP) \\
\hline
oai-smf & oaisoftwarealliance/oai-smf:v1.5.1 & 8080 (SBI), 8805 (N4) \\
\hline
oai-upf & oaisoftwarealliance/oai-spgwu-tiny:v1.5.1 & 8805 (N4), 2152 (GTP-U) \\
\hline
oai-udm & oaisoftwarealliance/oai-udm:v1.5.1 & 8080 (SBI) \\
\hline
oai-udr & oaisoftwarealliance/oai-udr:v1.5.1 & 8080 (SBI) \\
\hline
oai-ausf & oaisoftwarealliance/oai-ausf:v1.5.1 & 8080 (SBI) \\
\hline
mysql & mysql:8.0 & 3306 \\
\hline
\end{tabular}
\end{table}

\subsection{RAN and RIC Pods}

\begin{table}[H]
\centering
\caption{RAN and RIC pod deployments}
\label{tab:ran_pods}
\begin{tabular}{|l|l|p{5cm}|}
\hline
\textbf{Pod Name} & \textbf{Image} & \textbf{Key Configuration} \\
\hline
oai-gnb & oaisoftwarealliance/oai-gnb:develop & RFSIM mode, E2 Agent enabled, Band n78 \\
\hline
oai-nr-ue & oaisoftwarealliance/oai-nr-ue:develop & RFSIM mode, IMSI configuration \\
\hline
oai-flexric & oaisoftwarealliance/oai-flexric:latest & near-RT RIC, xApp runtime \\
\hline
\end{tabular}
\end{table}

\begin{figure}[H]
    \centering
    % \includegraphics[width=0.9\textwidth]{figures/k8s_pods.png}
    \fbox{\parbox{0.85\textwidth}{\centering\vspace{3cm}\textbf{[PLACEHOLDER: Kubernetes Pod Architecture]}\\\textit{Insert kubectl get pods output screenshot or diagram showing all running pods}\vspace{3cm}}}
    \caption{Kubernetes pods deployed in the blueprint namespace.}
    \label{fig:k8s_pods}
\end{figure}

\section{Service Configuration}

Kubernetes Services provide stable network endpoints for inter-component communication. The deployment utilizes ClusterIP services for internal communication and exposes specific ports for external access where required.

\subsection{Core Network Services}

\begin{codeblock}[language=yaml]{Core Network Service Definition (excerpt)}
apiVersion: v1
kind: Service
metadata:
  name: oai-amf
  namespace: blueprint
spec:
  type: ClusterIP
  selector:
    app: oai-amf
  ports:
    - name: ngap
      port: 38412
      protocol: SCTP
    - name: sbi
      port: 8080
      protocol: TCP
\end{codeblock}

\subsection{FlexRIC Service}

The FlexRIC service exposes the E2 termination endpoint on port 36421 for E2 Node connections and port 36422 for xApp connections:

\begin{codeblock}[language=yaml]{FlexRIC Service Configuration}
apiVersion: v1
kind: Service
metadata:
  name: oai-flexric
  namespace: blueprint
spec:
  type: ClusterIP
  selector:
    app: oai-flexric
  ports:
    - name: e2-sctp
      port: 36421
      protocol: SCTP
    - name: xapp
      port: 36422
      protocol: SCTP
\end{codeblock}

\section{Deployment Automation}

The platform deployment is automated using Ansible playbooks, enabling reproducible and consistent deployments. The automation handles:

\begin{enumerate}
    \item Kubernetes namespace creation
    \item ConfigMap and Secret generation
    \item Sequential pod deployment respecting dependencies
    \item Service creation and endpoint verification
    \item Health check validation
\end{enumerate}

\subsection{Deployment Sequence}

The deployment follows a specific ordering to satisfy component dependencies:

\begin{enumerate}
    \item \textbf{Infrastructure}: MySQL database initialization
    \item \textbf{Core Network}: NRF $\rightarrow$ UDR $\rightarrow$ UDM $\rightarrow$ AUSF $\rightarrow$ AMF $\rightarrow$ SMF $\rightarrow$ UPF
    \item \textbf{RIC}: FlexRIC deployment and initialization
    \item \textbf{RAN}: gNB with E2 Agent $\rightarrow$ NR-UE
\end{enumerate}

\begin{figure}[H]
    \centering
    % \includegraphics[width=0.85\textwidth]{figures/deployment_sequence.png}
    \fbox{\parbox{0.8\textwidth}{\centering\vspace{2.5cm}\textbf{[PLACEHOLDER: Deployment Sequence Diagram]}\\\textit{Insert sequence diagram showing component startup order}\vspace{2.5cm}}}
    \caption{Component deployment sequence ensuring proper dependency resolution.}
    \label{fig:deploy_sequence}
\end{figure}

\section{Resource Management}

Each pod is configured with appropriate resource requests and limits to ensure stable operation:

\begin{table}[H]
\centering
\caption{Pod resource allocations}
\label{tab:resources}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Component} & \textbf{CPU Request} & \textbf{CPU Limit} & \textbf{Memory Request} & \textbf{Memory Limit} \\
\hline
oai-gnb & 2000m & 4000m & 2Gi & 4Gi \\
\hline
oai-nr-ue & 1000m & 2000m & 1Gi & 2Gi \\
\hline
oai-amf & 500m & 1000m & 512Mi & 1Gi \\
\hline
oai-smf & 500m & 1000m & 512Mi & 1Gi \\
\hline
oai-upf & 500m & 1000m & 512Mi & 1Gi \\
\hline
oai-flexric & 500m & 1000m & 512Mi & 1Gi \\
\hline
\end{tabular}
\end{table}

\section{Persistent Storage}

The MySQL database utilizes a Persistent Volume Claim (PVC) to maintain subscriber data across pod restarts:

\begin{codeblock}[language=yaml]{Persistent Volume Claim for MySQL}
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: blueprint
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
\end{codeblock}
